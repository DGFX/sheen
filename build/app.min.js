var $jscomp=$jscomp||{};$jscomp.scope={};$jscomp.ASSUME_ES5=!1;$jscomp.ASSUME_NO_NATIVE_MAP=!1;$jscomp.ASSUME_NO_NATIVE_SET=!1;$jscomp.SIMPLE_FROUND_POLYFILL=!1;$jscomp.defineProperty=$jscomp.ASSUME_ES5||"function"==typeof Object.defineProperties?Object.defineProperty:function(a,b,c){a!=Array.prototype&&a!=Object.prototype&&(a[b]=c.value)};$jscomp.getGlobal=function(a){return"undefined"!=typeof window&&window===a?a:"undefined"!=typeof global&&null!=global?global:a};$jscomp.global=$jscomp.getGlobal(this);
$jscomp.polyfill=function(a,b,c,d){if(b){c=$jscomp.global;a=a.split(".");for(d=0;d<a.length-1;d++){var e=a[d];e in c||(c[e]={});c=c[e]}a=a[a.length-1];d=c[a];b=b(d);b!=d&&null!=b&&$jscomp.defineProperty(c,a,{configurable:!0,writable:!0,value:b})}};
$jscomp.polyfill("Array.from",function(a){return a?a:function(a,c,d){c=null!=c?c:function(a){return a};var b=[],f="undefined"!=typeof Symbol&&Symbol.iterator&&a[Symbol.iterator];if("function"==typeof f){a=f.call(a);for(var g=0;!(f=a.next()).done;)b.push(c.call(d,f.value,g++))}else for(f=a.length,g=0;g<f;g++)b.push(c.call(d,a[g],g));return b}},"es6","es3");
$jscomp.polyfill("Array.prototype.fill",function(a){return a?a:function(a,c,d){var b=this.length||0;0>c&&(c=Math.max(0,b+c));if(null==d||d>b)d=b;d=Number(d);0>d&&(d=Math.max(0,b+d));for(c=Number(c||0);c<d;c++)this[c]=a;return this}},"es6","es3");$jscomp.polyfill("Object.is",function(a){return a?a:function(a,c){return a===c?0!==a||1/a===1/c:a!==a&&c!==c}},"es6","es3");
$jscomp.polyfill("Array.prototype.includes",function(a){return a?a:function(a,c){var b=this;b instanceof String&&(b=String(b));var e=b.length;c=c||0;for(0>c&&(c=Math.max(c+e,0));c<e;c++){var f=b[c];if(f===a||Object.is(f,a))return!0}return!1}},"es7","es3");
$jscomp.checkStringArgs=function(a,b,c){if(null==a)throw new TypeError("The 'this' value for String.prototype."+c+" must not be null or undefined");if(b instanceof RegExp)throw new TypeError("First argument to String.prototype."+c+" must not be a regular expression");return a+""};$jscomp.polyfill("String.prototype.includes",function(a){return a?a:function(a,c){return-1!==$jscomp.checkStringArgs(this,a,"includes").indexOf(a,c||0)}},"es6","es3");
function init(a){var b=new THREE.MeshPhysicalMaterial({color:3750201,metalness:.9,roughness:.4,dithering:!0}),c=new THREE.PlaneBufferGeometry(16E3,16E3);b=new THREE.Mesh(c,b);b.receiveShadow=!0;b.rotation.x+=.9*Math.PI;b.position.set(0,-100,2E3);a.add(b)}var geometry,faces,colors,vertices=[],constraints=[];
function calculate(){var a=new THREE.IcosahedronBufferGeometry(100,5);geometry=THREE.BufferGeometryUtils.mergeVertices(a,1.5);populateVertices();faces=Array.from({length:vertices.length},function(){return[]});colors=Array.from({length:vertices.length},function(){return Array(8).fill()});populateConstraints();populateColors()}function populateVertices(){for(var a=new THREE.Vector3,b=geometry.attributes.position,c=0,d=b.count;c<d;c++)a.fromBufferAttribute(b,c),vertices.push(a.clone())}
function populateConstraints(){for(var a=geometry.index,b=Array.from({length:vertices.length},function(){return[]}),c=0,d=a.count/3;c<d;c++){var e=3*c,f=a.getX(e+0),g=a.getX(e+1);e=a.getX(e+2);faces[f].push([g,e]);faces[g].push([e,f]);faces[e].push([f,g]);b[g].includes(f)||(b[f].push(g),b[g].push(f),constraints.push([f,g]));b[e].includes(f)||(b[f].push(e),b[e].push(f),constraints.push([f,e]));b[e].includes(g)||(b[g].push(e),b[e].push(g),constraints.push([g,e]))}}
function populateColors(){for(var a=0,b=constraints.length;a<b;a++)for(var c=constraints[a],d=0;;){for(;void 0!==colors[c[0]][d];)d++;if(void 0===colors[c[1]][d]){colors[c[0]][d]=c[1];colors[c[1]][d]=c[0];break}else d++}}function dispose(){constraints=colors=faces=void 0}var camera,interacting=!1,psel=void 0,mouse=new THREE.Vector2,tmpmouse=new THREE.Vector3,mouse3d=new THREE.Vector3,raycaster=new THREE.Raycaster,plane=new THREE.Plane(void 0,-180),sphere=new THREE.Sphere(void 0,100);
function init$1(a){camera=a;window.addEventListener("mousemove",onMouseMove);window.addEventListener("mousedown",onMouseDown);window.addEventListener("mouseup",onMouseUp)}
function updating(){if(interacting){raycaster.setFromCamera(mouse,camera);if(null!=raycaster.ray.intersectSphere(sphere,tmpmouse)&&(mouse3d.copy(tmpmouse),void 0==psel))for(var a=Infinity,b=0;b<vertices.length;b++){var c=mouse3d.distanceTo(vertices[b]);c<a&&(a=c,psel=b)}plane.normal.copy(camera.position).normalize();null!=raycaster.ray.intersectPlane(plane,tmpmouse)&&mouse3d.copy(tmpmouse);return interacting&&psel?!0:!1}}
function onMouseMove(a){mouse.x=a.pageX/window.innerWidth*2-1;mouse.y=2*-(a.pageY/window.innerHeight)+1}function onMouseDown(a){0==a.button&&(interacting=!0)}function onMouseUp(a){0==a.button&&(interacting=!1,psel=void 0)}
var through_vert="\nprecision highp float;\n\nattribute vec2 position;\n\nvoid main() {\n\n\tgl_Position = vec4( position, vec2(1.0) );\n\n}\n",constraints_frag="\nprecision highp float;\n\nuniform int cID;\nuniform float length;\n\nuniform vec2 tSize;\n\nuniform sampler2D tPosition;\nuniform sampler2D tOriginal;\nuniform sampler2D tConstraints;\n\nvec2 getUV( float id ) {\n\n\tfloat div = id / tSize.x;\n\tfloat d = floor( div );\n\n\tfloat y = d / tSize.x;\n\tfloat x = div - d;\n\n\tfloat off = 0.5 / tSize.x;\n\n\treturn vec2( x + off, y + off );\n\n}\n\nvoid main() {\n\n\tvec2 uv = gl_FragCoord.xy / tSize.xy;\n\n\tvec3 orgA = texture2D( tOriginal, uv ).xyz;\n\tvec3 posA = texture2D( tPosition, uv ).xyz;\n\n\tfloat idx;\n\tvec2 idxColor;\n\n\tif ( cID == 0 )\n\t\tidxColor = texture2D( tConstraints, uv ).xy;\n\tif ( cID == 1 )\n\t\tidxColor = texture2D( tConstraints, uv ).zw;\n\n\tidx = idxColor.r * 255.0 + idxColor.g * 255.0 * 256.0;\n\n\tuv = getUV( idx );\n\n\tvec3 orgB = texture2D( tOriginal, uv ).xyz;\n\tvec3 posB = texture2D( tPosition, uv ).xyz;\n\n\tvec3 offOrg = ( orgB - orgA );\n\tvec3 offCur = ( posB - posA );\n\n\tfloat restDist = dot( offOrg, offOrg );\n\tfloat curDist = dot( offCur, offCur );\n\n\tfloat diff = restDist / ( curDist + restDist ) - 0.5;\n\n\tif ( diff > 0.0 ) diff *= 0.25;\n\tif ( idx > length ) diff = 0.0;\n\n\tposA -= offCur * diff * 0.52;\n\n\tgl_FragColor = vec4( posA, 1.0 );\n\n}\n",integrate_frag=
"\nprecision highp float;\n\n\nuniform float dt;\nuniform vec2 tSize;\n\nuniform sampler2D tOriginal;\nuniform sampler2D tPrevious;\nuniform sampler2D tPosition;\n\nvoid main() {\n\n\tfloat dt2 = dt * dt;\n\n\tvec2 uv = gl_FragCoord.xy / tSize.xy;\n\n\tvec3 org = texture2D( tOriginal, uv ).xyz;\n\tvec3 prv = texture2D( tPrevious, uv ).xyz;\n\tvec3 pos = texture2D( tPosition, uv ).xyz;\n\n\tvec3 offset = ( org - pos ) * 20.5 * dt2 * 8.33333;\n\tvec3 disp = ( pos - prv ) * 0.91 + pos;\n\n\tgl_FragColor = vec4( disp + offset, 1.0 );\n\n}\n",
mouse_frag="\nprecision highp float;\n\nuniform float psel;\nuniform vec2 tSize;\nuniform vec3 mouse;\nuniform sampler2D tPosition;\nuniform sampler2D tOriginal;\n\nvec2 getUV( float id ) {\n\n\tfloat div = id / tSize.x;\n\tfloat d = floor( div );\n\n\tfloat y = d / tSize.x;\n\tfloat x = div - d;\n\n\tfloat off = 0.5 / tSize.x;\n\n\treturn vec2( x + off, y + off );\n\n}\n\nvoid main() {\n\n\tvec3 diff, proj;\n\n\tvec2 uv = gl_FragCoord.xy / tSize.xy;\n\tvec3 pos = texture2D( tPosition, uv ).xyz;\n\tvec3 org = texture2D( tOriginal, uv ).xyz;\n\n\tuv = getUV( psel );\n\tvec3 ref = texture2D( tOriginal, uv ).xyz;\n\n\tvec3 offset = mouse - ref;\n\n\tif ( distance( org, ref ) <= 10.0 )  {\n\n\t\tdiff = ref - org;\n\n\t\tproj = dot( diff, offset ) / dot( offset, offset ) * org;\n\n\t\tpos = org + proj + offset;\n\n\t}\n\n\tgl_FragColor = vec4( pos, 1.0 );\n\n}\n",
normals_frag="\nprecision highp float;\n\nuniform int reset;\nuniform float length;\n\nuniform vec2 tSize;\n\nuniform sampler2D tPosition;\nuniform sampler2D tNormal;\nuniform sampler2D tFace;\n\nvec2 getUV( float id ) {\n\n\tfloat div = id / tSize.x;\n\tfloat d = floor( div );\n\n\tfloat y = d / tSize.x;\n\tfloat x = div - d;\n\n\tfloat off = 0.5 / tSize.x;\n\n\treturn vec2( x + off, y + off );\n\n}\n\nvoid main() {\n\n\tvec2 uv = gl_FragCoord.xy / tSize.xy;\n\tvec3 a = texture2D( tPosition, uv ).xyz;\n\n\tvec2 uvB, uvC;\n\tvec3 fNormal, b, c;\n\n\tvec3 normal = ( reset == 1 ) ? vec3( 0.0 ) : texture2D( tNormal, uv ).xyz;\n\n\tfloat idx;\n\n\tvec2 bColor = texture2D( tFace, uv ).xy;\n\tidx = bColor.r * 255.0 + bColor.g * 255.0 * 256.0;\n\tuvB = getUV( idx );\n\n\tvec2 cColor = texture2D( tFace, uv ).zw;\n\tidx = cColor.r * 255.0 + cColor.g * 255.0 * 256.0;\n\tuvC = getUV( idx );\n\n\tb = texture2D( tPosition, uvB ).xyz;\n\tc = texture2D( tPosition, uvC ).xyz;\n\n\tfNormal = cross( ( c - b ), ( a - b ) );\n\n\tif ( idx <= length ) normal += fNormal;\n\n\tgl_FragColor = vec4( normal, 1.0 );\n\n}\n",
through_frag="\nprecision highp float;\n\nuniform vec2 tSize;\nuniform sampler2D texture;\n\nvoid main() {\n\n\tvec2 uv = gl_FragCoord.xy / tSize.xy;\n\tgl_FragColor = texture2D( texture, uv );\n\n}\n",copyShader=new THREE.RawShaderMaterial({uniforms:{tSize:{type:"v2"},texture:{type:"t"}},vertexShader:through_vert,fragmentShader:through_frag,fog:!1,lights:!1,depthWrite:!1,depthTest:!1}),integrateShader=copyShader.clone();integrateShader.fragmentShader=integrate_frag;
integrateShader.uniforms={dt:{type:"f"},tSize:{type:"v2"},tOriginal:{type:"t"},tPrevious:{type:"t"},tPosition:{type:"t"}};var mouseShader=copyShader.clone();mouseShader.fragmentShader=mouse_frag;mouseShader.uniforms={psel:{value:null},tSize:{type:"v2"},mouse:{type:"v3"},tOriginal:{type:"t"},tPosition:{type:"t"}};var constraintsShader=copyShader.clone();constraintsShader.fragmentShader=constraints_frag;
constraintsShader.uniforms={cID:{value:null},length:{value:null},tSize:{type:"v2"},tOriginal:{type:"t"},tPosition:{type:"t"},tConstraints:{type:"t"}};var normalsShader=copyShader.clone();normalsShader.fragmentShader=normals_frag;normalsShader.uniforms={reset:{value:null},length:{value:null},tSize:{type:"v2"},tPosition:{type:"t"},tNormal:{type:"t"},tFace:{type:"t"}};
var RESOLUTION,renderer,mesh,targetRT,ntargetRT,normalsRT,originalRT,previousRT,positionRT,constraintsRT,facesRT,steps=60,tSize=new THREE.Vector2,scene=new THREE.Scene,camera$1=new THREE.Camera,clock=new THREE.Clock;
function init$2(a){renderer=a;RESOLUTION=Math.ceil(Math.sqrt(vertices.length));tSize.set(RESOLUTION,RESOLUTION);a=new THREE.BufferGeometry;var b=new Float32Array([-1,-1,3,-1,-1,3]);a.addAttribute("position",new THREE.BufferAttribute(b,2));mesh=new THREE.Mesh(a,copyShader);mesh.frustumCulled=!1;scene.add(mesh);originalRT=createRenderTarget();targetRT=createRenderTarget();ntargetRT=createRenderTarget();previousRT=createRenderTarget();positionRT=createRenderTarget();normalsRT=createRenderTarget();constraintsRT=
Array.from({length:4},createURenderTarget);facesRT=Array.from({length:6},createURenderTarget);copyTexture(createPositionTexture(),originalRT);copyTexture(originalRT,previousRT);copyTexture(originalRT,positionRT);for(a=0;4>a;a++)copyTexture(createConstraintsTexture(2*a),constraintsRT[a]);for(a=0;6>a;a++)copyTexture(createFacesTexture(a),facesRT[a])}
function copyTexture(a,b){mesh.material=copyShader;copyShader.uniforms.tSize.value=tSize;copyShader.uniforms.texture.value=a.texture;renderer.setRenderTarget(b);renderer.render(scene,camera$1)}function createURenderTarget(){createRenderTarget(!0)}
function createRenderTarget(a){return new THREE.WebGLRenderTarget(RESOLUTION,RESOLUTION,{wrapS:THREE.ClampToEdgeWrapping,wrapT:THREE.ClampToEdgeWrapping,minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter,format:THREE.RGBAFormat,type:a?THREE.UnsignedByteType:THREE.HalfFloatType,depthTest:!1,depthWrite:!1,depthBuffer:!1,stencilBuffer:!1})}
function createPositionTexture(){for(var a=new Float32Array(RESOLUTION*RESOLUTION*4),b=vertices.length,c=0;c<b;c++){var d=4*c;a[d+0]=vertices[c].x;a[d+1]=vertices[c].y;a[d+2]=vertices[c].z}b={};b.texture=new THREE.DataTexture(a,RESOLUTION,RESOLUTION,THREE.RGBAFormat,THREE.FloatType);b.texture.minFilter=THREE.NearestFilter;b.texture.magFilter=THREE.NearestFilter;b.texture.needsUpdate=!0;b.texture.generateMipmaps=!1;b.texture.flipY=!1;return b}
function createConstraintsTexture(a){for(var b=new Uint8Array(RESOLUTION*RESOLUTION*4),c=vertices.length,d=0;d<c;d++)for(var e=4*d,f=0;2>f;f++){var g=colors[d][a+f];void 0==g&&(g=c+1);b[e+2*f+0]=g%256;b[e+2*f+1]=~~(g/256)}a={};a.texture=new THREE.DataTexture(b,RESOLUTION,RESOLUTION,THREE.RGBAFormat,THREE.UnsignedByteType);a.texture.minFilter=THREE.NearestFilter;a.texture.magFilter=THREE.NearestFilter;a.texture.needsUpdate=!0;a.texture.generateMipmaps=!1;a.texture.flipY=!1;return a}
function createFacesTexture(a){for(var b=new Uint8Array(RESOLUTION*RESOLUTION*4),c=vertices.length,d=0;d<c;d++)for(var e=4*d,f=faces[d][a],g=0;2>g;g++){var h=void 0==f?c+1:f[g];b[e+2*g+0]=h%256;b[e+2*g+1]=~~(h/256)}a={};a.texture=new THREE.DataTexture(b,RESOLUTION,RESOLUTION,THREE.RGBAFormat,THREE.UnsignedByteType);a.texture.minFilter=THREE.NearestFilter;a.texture.magFilter=THREE.NearestFilter;a.texture.needsUpdate=!0;a.texture.generateMipmaps=!1;a.texture.flipY=!1;return a}
function integrate(){var a=clock.getDelta();mesh.material=integrateShader;integrateShader.uniforms.tSize.value=tSize;integrateShader.uniforms.dt.value=.016<a?.016:a;integrateShader.uniforms.tOriginal.value=originalRT.texture;integrateShader.uniforms.tPrevious.value=previousRT.texture;integrateShader.uniforms.tPosition.value=positionRT.texture;renderer.setRenderTarget(targetRT);renderer.render(scene,camera$1);a=previousRT;previousRT=positionRT;positionRT=targetRT;targetRT=a}
function solveConstraints(a){mesh.material=constraintsShader;constraintsShader.uniforms.length.value=vertices.length;constraintsShader.uniforms.tSize.value=tSize;constraintsShader.uniforms.cID.value=a%2;constraintsShader.uniforms.tOriginal.value=originalRT.texture;constraintsShader.uniforms.tPosition.value=positionRT.texture;constraintsShader.uniforms.tConstraints.value=constraintsRT[~~(a/2)].texture;renderer.setRenderTarget(targetRT);renderer.render(scene,camera$1);a=positionRT;positionRT=targetRT;
targetRT=a}function mouseOffset(){mesh.material=mouseShader;mouseShader.uniforms.tSize.value=tSize;mouseShader.uniforms.psel.value=psel;mouseShader.uniforms.mouse.value=mouse3d;mouseShader.uniforms.tOriginal.value=originalRT.texture;mouseShader.uniforms.tPosition.value=positionRT.texture;renderer.setRenderTarget(targetRT);renderer.render(scene,camera$1);var a=positionRT;positionRT=targetRT;targetRT=a}
function computeVertexNormals(a){mesh.material=normalsShader;normalsShader.uniforms.reset.value=0==a?1:0;normalsShader.uniforms.length.value=vertices.length;normalsShader.uniforms.tSize.value=tSize;normalsShader.uniforms.tPosition.value=positionRT.texture;normalsShader.uniforms.tNormal.value=normalsRT.texture;normalsShader.uniforms.tFace.value=facesRT[a].texture;renderer.setRenderTarget(ntargetRT);renderer.render(scene,camera$1);a=normalsRT;normalsRT=ntargetRT;ntargetRT=a}
function update(){integrate();for(var a=0;a<steps;a++){updating()&&a+5<steps&&mouseOffset();for(var b=0;8>b;b++)solveConstraints(b)}for(a=0;6>a;a++)computeVertexNormals(a)}
var physical_frag='\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs#L94\nfloat D_Charlie(float roughness, float NoH) {\n\t// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125); // 2^(-14/2), so sin2h^2 > 0 in fp16\n\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs#L136\nfloat V_Neubelt(float NoV, float NoL) {\n\t// Neubelt and Pettineo 2013, "Crafting a Next-gen Material Pipeline for The Order: 1886"\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nfloat BDRF_Diffuse_Sheen( const in float sheen, const in IncidentLight incidentLight, const in GeometricContext geometry ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 L = incidentLight.direction;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\tfloat thetaH = acos( dotNH );\n\treturn D_Charlie( sheen, dot(N, H) ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n\nstruct PhysicalMaterial {\n\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t\tfloat sheen;\n\t#endif\n\n};\n\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\n\n// Clear coat directional hemishperical reflectance (this approximation should be improved)\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n\n}\n\n#if NUM_RECT_AREA_LIGHTS > 0\n\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight; // counterclockwise; light shines in local neg z direction\n\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\n\t\t// LTC Fresnel Approximation by Stephen Hill\n\t\t// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\n\t}\n\n#endif\n\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\n\tvec3 irradiance = dotNL * directLight.color;\n\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\tirradiance *= PI; // punctual light\n\n\t#endif\n\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\n\n\tfloat sheenMix;\n\t#ifndef STANDARD\n\t\tfloat sheenFactor = 0.7;\n\t\tif(sheenFactor == 0.) sheenMix = 0.;\n\t\telse sheenMix = 1. - pow(1. - sheenFactor, 5.);\n\t#else\n\t\tsheenMix = 0.;\n\t#endif\n\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor ) * (1. - sheenMix);\n\t#ifndef STANDARD\n\t\t// avoid expensive calculation\n\t\tif(sheenMix > 0.) reflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * material.diffuseColor * irradiance * sheenMix * BDRF_Diffuse_Sheen( sheenFactor, directLight, geometry );\n\t#endif\n\n\t#ifndef STANDARD\n\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\n\t#endif\n\n}\n\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\t// Defer to the IndirectSpecular function to compute\n\t// the indirectDiffuse if energy preservation is enabled.\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\n\t\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n\t#endif\n\n}\n\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\n\tfloat clearCoatInv = 1.0 - clearCoatDHR;\n\n\t// Both indirect specular and diffuse light accumulate here\n\t// if energy preservation enabled, and PMREM provided.\n\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\tvec3 singleScattering = vec3( 0.0 );\n\t\tvec3 multiScattering = vec3( 0.0 );\n\t\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\n\t\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\n\t\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\n\t\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\n\t\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\n\t#else\n\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\n\t#endif\n\n\t#ifndef STANDARD\n\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\n\t#endif\n}\n\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\n\n// ref: https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n\n}\n',RESOLUTION$1,
mesh$1;
function init$3(a){RESOLUTION$1=Math.ceil(Math.sqrt(vertices.length));var b=(new THREE.TextureLoader).load("./src/textures/bmpMap.png");b=new THREE.MeshPhysicalMaterial({color:16767520,bumpMap:b,bumpScale:.25,metalness:.1,roughness:.6,clearCoat:.8,clearCoatRoughness:.35,dithering:!0});b.onBeforeCompile=function(a){a.uniforms.tPosition={value:positionRT.texture};a.uniforms.tNormal={value:normalsRT.texture};a.vertexShader="uniform sampler2D tPosition;\nuniform sampler2D tNormal;\n"+a.vertexShader;a.vertexShader=
a.vertexShader.replace("#include <beginnormal_vertex>","vec3 transformed = texture2D( tPosition, position.xy ).xyz;\n\t\t\t vec3 objectNormal = normalize( texture2D( tNormal, position.xy ).xyz );\n\t\t\t");a.vertexShader=a.vertexShader.replace("#include <begin_vertex>","");a.fragmentShader=a.fragmentShader.replace("#include <lights_physical_pars_fragment>",physical_frag)};var c=new THREE.MeshDepthMaterial;c.onBeforeCompile=function(a){a.uniforms.tPosition={value:positionRT.texture};a.vertexShader=
"uniform sampler2D tPosition;\n"+a.vertexShader;a.vertexShader=a.vertexShader.replace("#include <begin_vertex>","vec3 transformed = texture2D( tPosition, position.xy ).xyz;")};for(var d=new Float32Array(RESOLUTION$1*RESOLUTION$1*3),e=0,f=RESOLUTION$1*RESOLUTION$1;e<f;e++){var g=3*e;d[g+0]=e%RESOLUTION$1/RESOLUTION$1+.5/RESOLUTION$1;d[g+1]=~~(e/RESOLUTION$1)/RESOLUTION$1+.5/RESOLUTION$1}e=new THREE.BufferGeometry;e.setIndex(geometry.index);e.addAttribute("position",new THREE.BufferAttribute(d,3));
e.addAttribute("uv",geometry.attributes.uv);mesh$1=new THREE.Mesh(e,b);mesh$1.customDepthMaterial=c;mesh$1.castShadow=!0;a.add(mesh$1)}var objects,clock$1=new THREE.Clock;
function init$4(a){var b=new THREE.AmbientLight(16777215,0);b.baseIntensity=1;var c=new THREE.SpotLight(16616331,0,4E3,Math.PI/6,.2,.11);c.baseIntensity=3.6;c.position.set(.9,.1,-.5).multiplyScalar(400);c.castShadow=!0;c.shadow.radius=20;c.shadow.camera.far=4E3;c.shadow.mapSize.height=4096;c.shadow.mapSize.width=4096;var d=new THREE.SpotLight(4882408,0,4E3,Math.PI/6,.2,.11);d.baseIntensity=2.6;d.position.set(-.91,.1,-.5).multiplyScalar(400);d.castShadow=!0;d.shadow.radius=20;d.shadow.camera.far=4E3;
d.shadow.mapSize.height=4096;d.shadow.mapSize.width=4096;var e=new THREE.SpotLight(16777215,0,4E3,Math.PI/5.5,1.4,.08);e.baseIntensity=1.8;e.position.set(0,0,-1).multiplyScalar(400);e.castShadow=!0;e.shadow.radius=5;e.shadow.camera.far=4E3;e.shadow.mapSize.height=4096;e.shadow.mapSize.width=4096;var f=new THREE.DirectionalLight(16777215,0);f.baseIntensity=.3;f.position.set(0,1,.5);var g=new THREE.DirectionalLight(16777215,0);g.baseIntensity=1.3;g.position.set(0,1,-.4);a.add(b,c,d,e,f,g);objects=[b,
c,d,e,f,g]}function update$1(){var a=clock$1.getElapsedTime();if(1<a&&4>a)for(var b=0;b<objects.length;b++){var c=objects[b],d=objects[b].baseIntensity;var e=(a-1)/3;var f=1>(e/=.5)?.5*e*e*e:.5*((e-=2)*e*e+2);c.intensity=d*f}}var renderer$1,camera$2,scene$1;
function init$5(){renderer$1=new THREE.WebGLRenderer({antialias:!0});renderer$1.setSize(window.innerWidth,window.innerHeight);renderer$1.setPixelRatio(window.devicePixelRatio);renderer$1.gammaOutput=!0;renderer$1.physicallyCorrectLights=!0;renderer$1.shadowMap.enabled=!0;renderer$1.shadowMap.type=THREE.PCFShadowMap;document.body.appendChild(renderer$1.domElement);scene$1=new THREE.Scene;scene$1.background=new THREE.Color(1184530);camera$2=new THREE.PerspectiveCamera(60,window.innerWidth/window.innerHeight,
1,1E4);camera$2.position.z=-350;camera$2.position.y=-50;camera$2.position.x=0;camera$2.lookAt(new THREE.Vector3);calculate();init(scene$1);init$4(scene$1);init$3(scene$1);init$1(camera$2,renderer$1.domElement);init$2(renderer$1);dispose();animate()}function animate(){requestAnimationFrame(animate);update$1();update();renderer$1.setRenderTarget(null);renderer$1.render(scene$1,camera$2)}
window.onresize=function(){var a=window.innerWidth,b=window.innerHeight;camera$2.aspect=a/b;camera$2.updateProjectionMatrix();renderer$1.setSize(a,b)};init$5();

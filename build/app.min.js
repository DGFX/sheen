var $jscomp=$jscomp||{};$jscomp.scope={};$jscomp.ASSUME_ES5=!1;$jscomp.ASSUME_NO_NATIVE_MAP=!1;$jscomp.ASSUME_NO_NATIVE_SET=!1;$jscomp.SIMPLE_FROUND_POLYFILL=!1;$jscomp.defineProperty=$jscomp.ASSUME_ES5||"function"==typeof Object.defineProperties?Object.defineProperty:function(a,b,d){a!=Array.prototype&&a!=Object.prototype&&(a[b]=d.value)};$jscomp.getGlobal=function(a){return"undefined"!=typeof window&&window===a?a:"undefined"!=typeof global&&null!=global?global:a};$jscomp.global=$jscomp.getGlobal(this);
$jscomp.polyfill=function(a,b,d,c){if(b){d=$jscomp.global;a=a.split(".");for(c=0;c<a.length-1;c++){var e=a[c];e in d||(d[e]={});d=d[e]}a=a[a.length-1];c=d[a];b=b(c);b!=c&&null!=b&&$jscomp.defineProperty(d,a,{configurable:!0,writable:!0,value:b})}};
$jscomp.polyfill("Array.from",function(a){return a?a:function(a,d,c){d=null!=d?d:function(a){return a};var b=[],f="undefined"!=typeof Symbol&&Symbol.iterator&&a[Symbol.iterator];if("function"==typeof f){a=f.call(a);for(var g=0;!(f=a.next()).done;)b.push(d.call(c,f.value,g++))}else for(f=a.length,g=0;g<f;g++)b.push(d.call(c,a[g],g));return b}},"es6","es3");
function init(a){var b=new THREE.MeshPhysicalMaterial({color:3750201,metalness:.9,roughness:.4,dithering:!0}),d=new THREE.PlaneBufferGeometry(16E3,16E3);b=new THREE.Mesh(d,b);b.receiveShadow=!0;b.rotation.x+=.9*Math.PI;b.position.set(0,-100,2E3);a.add(b)}var geometry,adjacency,vertices;function calculate(){var a=new THREE.IcosahedronBufferGeometry(100,5);geometry=THREE.BufferGeometryUtils.mergeVertices(a,1.5);populateVertices();populateAdjacency()}
function populateVertices(){var a=new THREE.Vector3,b=geometry.attributes.position;vertices=[];for(var d=0,c=b.count;d<c;d++)a.fromBufferAttribute(b,d),vertices.push(a.clone())}
function populateAdjacency(){function a(a,b,c){for(var d=0;d<a.length;d++){var e=a[d];if(e.a===b&&e.b===c||e.b===b&&e.c===c||e.c===b&&e.a===c)return e}console.error("sheen.error: shouldn't reach here.")}for(var b=geometry.index,d=Array.from({length:vertices.length},function(){return[]}),c=0,e=b.count/3;c<e;c++){var f=3*c,g=b.getX(f+0),k=b.getX(f+1);f=b.getX(f+2);var h=new THREE.Face3(g,k,f);d[g].push(h);d[k].push(h);d[f].push(h)}adjacency=Array.from({length:vertices.length},function(){return[]});
for(b=0;b<d.length;b++)for(c=d[b][0];c.a==b?(adjacency[b].push(c.c),c=a(d[b],b,c.c)):c.b==b?(adjacency[b].push(c.a),c=a(d[b],b,c.a)):(adjacency[b].push(c.b),c=a(d[b],b,c.b)),c!=d[b][0];);}function dispose(){adjacency=geometry=void 0}var camera,interacting=!1,psel=void 0,mouse=new THREE.Vector2,tmpmouse=new THREE.Vector3,mouse3d=new THREE.Vector3,raycaster=new THREE.Raycaster,plane=new THREE.Plane(void 0,-180),sphere=new THREE.Sphere(void 0,100);
function init$1(a){camera=a;window.addEventListener("mousemove",onMouseMove);window.addEventListener("mousedown",onMouseDown);window.addEventListener("mouseup",onMouseUp)}
function updating(){if(!interacting)return!1;raycaster.setFromCamera(mouse,camera);if(null!=raycaster.ray.intersectSphere(sphere,tmpmouse)&&(mouse3d.copy(tmpmouse),void 0==psel))for(var a=Infinity,b=0;b<vertices.length;b++){var d=mouse3d.distanceTo(vertices[b]);d<a&&(a=d,psel=b)}plane.normal.copy(camera.position).normalize();null!=raycaster.ray.intersectPlane(plane,tmpmouse)&&mouse3d.copy(tmpmouse);return interacting&&psel?!0:!1}
function onMouseMove(a){mouse.x=a.pageX/window.innerWidth*2-1;mouse.y=2*-(a.pageY/window.innerHeight)+1}function onMouseDown(a){0==a.button&&(interacting=!0)}function onMouseUp(a){0==a.button&&(interacting=!1,psel=void 0)}
var through_vert="\nprecision highp float;\n\nattribute vec2 position;\n\nvoid main() {\n\n\tgl_Position = vec4( position, vec2(1.0) );\n\n}\n",constraints_frag="\nprecision highp float;\n\nuniform vec2 tSize;\nuniform sampler2D tPosition;\n\nuniform sampler2D tDistancesA;\nuniform sampler2D tDistancesB;\n\nuniform sampler2D tAdjacentsA;\nuniform sampler2D tAdjacentsB;\n\n// get vec2 tex coordinate from index\nvec2 getUV( float id ) { \n\n\tvec2 coords = vec2(\n\t\tfloor( mod( ( id + 0.5 ), tSize.x ) ),\n\t\tfloor( ( id + 0.5 ) / tSize.x )\n\t) + 0.5;\n\n\treturn coords / tSize;\n\n}\n\n// compute offset based on current distance and spring rest distance\nvec3 getDisplacement( vec3 point0, vec3 point1, float restDistance ) {\n\n    float curDistance = distance( point0, point1 );\n\treturn 1.5 * ( curDistance - restDistance ) * ( point1 - point0 ) / curDistance;\n\t\n}\n\nvoid main() {\n\t\n\tvec3 displacement;\n\tvec2 uv = gl_FragCoord.xy / tSize.xy;\n\n\t// indices of adjacent vertices\n\tvec4 adjacentA = texture2D( tAdjacentsA, uv );\n\tvec4 adjacentB = texture2D( tAdjacentsB, uv );\n\n\t// distances of adjacent vertices\n\tvec4 distancesA = texture2D( tDistancesA, uv );\n\tvec4 distancesB = texture2D( tDistancesB, uv );\n\n\t// vertex position\n\tvec3 p0 = texture2D( tPosition, uv ).xyz;\n\n\t// adjacent vertices positions\n    vec3 p1 = texture2D( tPosition, getUV( adjacentA.x ) ).xyz;\n    vec3 p2 = texture2D( tPosition, getUV( adjacentA.y ) ).xyz;\n    vec3 p3 = texture2D( tPosition, getUV( adjacentA.z ) ).xyz;\n    vec3 p4 = texture2D( tPosition, getUV( adjacentA.w ) ).xyz;\n    vec3 p5 = texture2D( tPosition, getUV( adjacentB.x ) ).xyz;\n\tvec3 p6 = texture2D( tPosition, getUV( adjacentB.y ) ).xyz;\n\t\n\t// spring-based displacement\n    displacement += getDisplacement( p0, p1, distancesA.x );\n    displacement += getDisplacement( p0, p2, distancesA.y );\n    displacement += getDisplacement( p0, p3, distancesA.z );\n    displacement += getDisplacement( p0, p4, distancesA.w );\n    displacement += getDisplacement( p0, p5, distancesB.x );\n    displacement += ( adjacentB.y > 0.0 ) ? getDisplacement( p0, p6, distancesB.y ) : vec3( 0 );\n\n\tp0 += 0.93 * displacement / ( ( adjacentB.y > 0.0 ) ? 6.0 : 5.0 );\n\n\tgl_FragColor = vec4( p0, 1.0 );\n\n}\n",integrate_frag=
"\nprecision highp float;\n\nuniform vec2 tSize;\n\nuniform sampler2D tOriginal;\nuniform sampler2D tPrevious;\nuniform sampler2D tPosition;\n\n#define dt 0.016\n\nvoid main() {\n\n\tfloat dt2 = dt * dt;\n\n\tvec2 uv = gl_FragCoord.xy / tSize.xy;\n\n\tvec3 org = texture2D( tOriginal, uv ).xyz;\n\tvec3 prv = texture2D( tPrevious, uv ).xyz;\n\tvec3 pos = texture2D( tPosition, uv ).xyz;\n\n\tvec3 offset = ( org - pos ) * 20.5 * dt2 * 8.33333;\n\tvec3 disp = ( pos - prv ) * 0.91 + pos;\n\n\tgl_FragColor = vec4( disp + offset, 1.0 );\n\n}\n",
mouse_frag="\nprecision highp float;\n\nuniform float psel;\nuniform vec2 tSize;\nuniform vec3 mouse;\nuniform sampler2D tPosition;\nuniform sampler2D tOriginal;\n\n// get vec2 tex coordinate from index\nvec2 getUV( float id ) { \n\n\tvec2 coords = vec2(\n\t\tfloor( mod( ( id + 0.5 ), tSize.x ) ),\n\t\tfloor( ( id + 0.5 ) / tSize.x )\n\t) + 0.5;\n\n\treturn coords / tSize;\n\n}\n\nvoid main() {\n\n\tvec2 uv = gl_FragCoord.xy / tSize.xy;\n\n\tvec3 pos = texture2D( tPosition, uv ).xyz;\n\tvec3 org = texture2D( tOriginal, uv ).xyz;\n\tvec3 ref = texture2D( tOriginal, getUV( psel ) ).xyz;\n\n\tvec3 diff, proj, offset = mouse - ref;\n\n\tif ( distance( org, ref ) <= 10.0 )  {\n\n\t\tdiff = ref - org;\n\n\t\tproj = dot( diff, offset ) / dot( offset, offset ) * org;\n\n\t\tpos = org + proj + offset;\n\n\t}\n\n\tgl_FragColor = vec4( pos, 1.0 );\n\n}\n",
normals_frag="\nprecision highp float;\n\nuniform vec2 tSize;\n\nuniform sampler2D tPosition;\n\nuniform sampler2D tAdjacentsA;\nuniform sampler2D tAdjacentsB;\n\n// get vec2 tex coordinate from index\nvec2 getUV( float id ) { \n\n\tvec2 coords = vec2(\n\t\tfloor( mod( ( id + 0.5 ), tSize.x ) ),\n\t\tfloor( ( id + 0.5 ) / tSize.x )\n\t) + 0.5;\n\n\treturn coords / tSize;\n\n}\n\nvoid main () {\n\n    vec3 normal;\n\tvec2 uv = gl_FragCoord.xy / tSize.xy;\n\n    // indices of adjacent vertices\n    vec4 adjacentsA = texture2D( tAdjacentsA, uv );\n    vec4 adjacentsB = texture2D( tAdjacentsB, uv );\n\n    // vertex position\n    vec3 p0 = texture2D( tPosition, uv ).xyz;\n\n    // adjacent vertices positions\n    vec3 p1 = texture2D( tPosition, getUV( adjacentsA.x ) ).xyz;\n    vec3 p2 = texture2D( tPosition, getUV( adjacentsA.y ) ).xyz;\n    vec3 p3 = texture2D( tPosition, getUV( adjacentsA.z ) ).xyz;\n    vec3 p4 = texture2D( tPosition, getUV( adjacentsA.w ) ).xyz;\n    vec3 p5 = texture2D( tPosition, getUV( adjacentsB.x ) ).xyz;\n    vec3 p6 = texture2D( tPosition, getUV( adjacentsB.y ) ).xyz;\n\n    // compute vertex normal contribution\n    normal += cross( p1 - p0, p2 - p0 );\n    normal += cross( p2 - p0, p3 - p0 );\n    normal += cross( p3 - p0, p4 - p0 );\n    normal += cross( p4 - p0, p5 - p0 );\n\n    if ( adjacentsB.y > 0.0 ) {\n\n        normal += cross( p5 - p0, p6 - p0 );\n        normal += cross( p6 - p0, p1 - p0 );\n\n    } else {\n\n        normal += cross( p5 - p0, p1 - p0 );\n\n    }\n\n    gl_FragColor = vec4( normalize( normal ), 1.0 );\n}\n",
through_frag="\nprecision highp float;\n\nuniform vec2 tSize;\nuniform sampler2D texture;\n\nvoid main() {\n\n\tvec2 uv = gl_FragCoord.xy / tSize.xy;\n\tgl_FragColor = texture2D( texture, uv );\n\n}\n",copyShader=new THREE.RawShaderMaterial({uniforms:{tSize:{type:"v2"},texture:{type:"t"}},vertexShader:through_vert,fragmentShader:through_frag,fog:!1,lights:!1,depthWrite:!1,depthTest:!1}),integrateShader=copyShader.clone();integrateShader.fragmentShader=integrate_frag;
integrateShader.uniforms={dt:{type:"f"},tSize:{type:"v2"},tOriginal:{type:"t"},tPrevious:{type:"t"},tPosition:{type:"t"}};var mouseShader=copyShader.clone();mouseShader.fragmentShader=mouse_frag;mouseShader.uniforms={psel:{value:null},tSize:{type:"v2"},mouse:{type:"v3"},tOriginal:{type:"t"},tPosition:{type:"t"}};var constraintsShader=copyShader.clone();constraintsShader.fragmentShader=constraints_frag;
constraintsShader.uniforms={tSize:{type:"v2"},tPosition:{type:"t"},tAdjacentsA:{type:"t"},tAdjacentsB:{type:"t"},tDistancesA:{type:"t"},tDistancesB:{type:"t"}};var normalsShader=copyShader.clone();normalsShader.fragmentShader=normals_frag;normalsShader.uniforms={tSize:{type:"v2"},tPosition:{type:"t"},tAdjacentsA:{type:"t"},tAdjacentsB:{type:"t"}};
var RESOLUTION,renderer,mesh,targetRT,normalsRT,originalRT,previousRT,positionRT,adjacentsRT,distancesRT,steps=40,tSize=new THREE.Vector2,scene=new THREE.Scene,camera$1=new THREE.Camera;
function init$2(a){renderer=a;RESOLUTION=Math.ceil(Math.sqrt(vertices.length));tSize.set(RESOLUTION,RESOLUTION);a=new THREE.BufferGeometry;var b=new Float32Array([-1,-1,3,-1,-1,3]);a.addAttribute("position",new THREE.BufferAttribute(b,2));mesh=new THREE.Mesh(a,copyShader);mesh.frustumCulled=!1;scene.add(mesh);scene.updateMatrixWorld=function(){};originalRT=createRenderTarget();targetRT=createRenderTarget();previousRT=createRenderTarget();positionRT=createRenderTarget();normalsRT=createRenderTarget();
adjacentsRT=Array.from({length:2},createRenderTarget);distancesRT=Array.from({length:2},createRenderTarget);copyTexture(createPositionTexture(),originalRT);copyTexture(originalRT,previousRT);copyTexture(originalRT,positionRT);for(a=0;2>a;a++)copyTexture(createAdjacentsTexture(4*a),adjacentsRT[a]);for(a=0;2>a;a++)copyTexture(createDistancesTexture(4*a),distancesRT[a])}
function copyTexture(a,b){mesh.material=copyShader;copyShader.uniforms.tSize.value=tSize;copyShader.uniforms.texture.value=a.texture;renderer.setRenderTarget(b);renderer.render(scene,camera$1)}
function createRenderTarget(){return new THREE.WebGLRenderTarget(RESOLUTION,RESOLUTION,{wrapS:THREE.ClampToEdgeWrapping,wrapT:THREE.ClampToEdgeWrapping,minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter,format:THREE.RGBAFormat,type:THREE.FloatType,depthTest:!1,depthWrite:!1,depthBuffer:!1,stencilBuffer:!1})}
function createPositionTexture(){for(var a=new Float32Array(RESOLUTION*RESOLUTION*4),b=vertices.length,d=0;d<b;d++){var c=4*d;a[c+0]=vertices[d].x;a[c+1]=vertices[d].y;a[c+2]=vertices[d].z}b={};b.texture=new THREE.DataTexture(a,RESOLUTION,RESOLUTION,THREE.RGBAFormat,THREE.FloatType);b.texture.minFilter=THREE.NearestFilter;b.texture.magFilter=THREE.NearestFilter;b.texture.needsUpdate=!0;b.texture.generateMipmaps=!1;b.texture.flipY=!1;return b}
function createAdjacentsTexture(a){for(var b=new Float32Array(RESOLUTION*RESOLUTION*4),d=vertices.length,c=0;c<d;c++){var e=4*c,f=adjacency[c],g=adjacency[c].length;b[e+0]=f[a+0];b[e+1]=6>g&&0<a?-1:f[a+1];b[e+2]=0<a?-1:f[a+2];b[e+3]=0<a?-1:f[a+3]}a={};a.texture=new THREE.DataTexture(b,RESOLUTION,RESOLUTION,THREE.RGBAFormat,THREE.FloatType);a.texture.minFilter=THREE.NearestFilter;a.texture.magFilter=THREE.NearestFilter;a.texture.needsUpdate=!0;a.texture.generateMipmaps=!1;a.texture.flipY=!1;return a}
function createDistancesTexture(a){for(var b=new Float32Array(RESOLUTION*RESOLUTION*4),d=vertices.length,c=vertices,e=0;e<d;e++){var f=4*e,g=adjacency[e],k=adjacency[e].length,h=c[e];b[f+0]=h.distanceTo(c[g[a+0]]);b[f+1]=6>k&&0<a?-1:h.distanceTo(c[g[a+1]]);b[f+2]=0<a?-1:h.distanceTo(c[g[a+2]]);b[f+3]=0<a?-1:h.distanceTo(c[g[a+3]])}a={};a.texture=new THREE.DataTexture(b,RESOLUTION,RESOLUTION,THREE.RGBAFormat,THREE.FloatType);a.texture.minFilter=THREE.NearestFilter;a.texture.magFilter=THREE.NearestFilter;
a.texture.needsUpdate=!0;a.texture.generateMipmaps=!1;a.texture.flipY=!1;return a}function integrate(){mesh.material=integrateShader;integrateShader.uniforms.tSize.value=tSize;integrateShader.uniforms.tOriginal.value=originalRT.texture;integrateShader.uniforms.tPrevious.value=previousRT.texture;integrateShader.uniforms.tPosition.value=positionRT.texture;renderer.setRenderTarget(targetRT);renderer.render(scene,camera$1);var a=previousRT;previousRT=positionRT;positionRT=targetRT;targetRT=a}
function solveConstraints(){mesh.material=constraintsShader;constraintsShader.uniforms.tSize.value=tSize;constraintsShader.uniforms.tPosition.value=positionRT.texture;constraintsShader.uniforms.tAdjacentsA.value=adjacentsRT[0].texture;constraintsShader.uniforms.tAdjacentsB.value=adjacentsRT[1].texture;constraintsShader.uniforms.tDistancesA.value=distancesRT[0].texture;constraintsShader.uniforms.tDistancesB.value=distancesRT[1].texture;renderer.setRenderTarget(targetRT);renderer.render(scene,camera$1);
var a=positionRT;positionRT=targetRT;targetRT=a}function mouseOffset(){mesh.material=mouseShader;mouseShader.uniforms.tSize.value=tSize;mouseShader.uniforms.psel.value=psel;mouseShader.uniforms.mouse.value=mouse3d;mouseShader.uniforms.tOriginal.value=originalRT.texture;mouseShader.uniforms.tPosition.value=positionRT.texture;renderer.setRenderTarget(targetRT);renderer.render(scene,camera$1);var a=positionRT;positionRT=targetRT;targetRT=a}
function computeVertexNormals(){mesh.material=normalsShader;normalsShader.uniforms.tSize.value=tSize;normalsShader.uniforms.tPosition.value=positionRT.texture;normalsShader.uniforms.tAdjacentsA.value=adjacentsRT[0].texture;normalsShader.uniforms.tAdjacentsB.value=adjacentsRT[1].texture;renderer.setRenderTarget(normalsRT);renderer.render(scene,camera$1)}function update(){integrate();for(var a=updating(),b=0;b<steps;b++)a&&b+5<steps&&mouseOffset(),solveConstraints();computeVertexNormals()}
var RESOLUTION$1,mesh$1;
function init$3(a){RESOLUTION$1=Math.ceil(Math.sqrt(vertices.length));var b=(new THREE.TextureLoader).load("./src/textures/bmpMap.png");b=new THREE.MeshPhysicalMaterial({color:16767520,bumpMap:b,bumpScale:.25,metalness:.1,roughness:.6,clearcoat:.8,clearcoatRoughness:.35,sheen:(new THREE.Color(.2,.2,1)).multiplyScalar(1/6),dithering:!0});b.onBeforeCompile=function(a){a.uniforms.tPosition={value:positionRT.texture};a.uniforms.tNormal={value:normalsRT.texture};a.vertexShader="uniform sampler2D tPosition;\nuniform sampler2D tNormal;\n"+
a.vertexShader;a.vertexShader=a.vertexShader.replace("#include <beginnormal_vertex>","vec3 transformed = texture2D( tPosition, position.xy ).xyz;\n\t\t\t vec3 objectNormal = normalize( texture2D( tNormal, position.xy ).xyz );\n\t\t\t");a.vertexShader=a.vertexShader.replace("#include <begin_vertex>","")};var d=new THREE.MeshDepthMaterial;d.onBeforeCompile=function(a){a.uniforms.tPosition={value:positionRT.texture};a.vertexShader="uniform sampler2D tPosition;\n"+a.vertexShader;a.vertexShader=a.vertexShader.replace("#include <begin_vertex>",
"vec3 transformed = texture2D( tPosition, position.xy ).xyz;")};for(var c=new Float32Array(RESOLUTION$1*RESOLUTION$1*3),e=0,f=RESOLUTION$1*RESOLUTION$1;e<f;e++){var g=3*e;c[g+0]=e%RESOLUTION$1/RESOLUTION$1+.5/RESOLUTION$1;c[g+1]=~~(e/RESOLUTION$1)/RESOLUTION$1+.5/RESOLUTION$1}e=new THREE.BufferGeometry;e.setIndex(geometry.index);e.addAttribute("position",new THREE.BufferAttribute(c,3));e.addAttribute("uv",geometry.attributes.uv);mesh$1=new THREE.Mesh(e,b);mesh$1.customDepthMaterial=d;mesh$1.castShadow=
!0;a.add(mesh$1)}var objects,clock=new THREE.Clock;
function init$4(a){var b=new THREE.AmbientLight(16777215,0);b.baseIntensity=.5;var d=new THREE.SpotLight(16616331,0,4E3,Math.PI/6,.2,.11);d.baseIntensity=3.6;d.position.set(.9,.1,-.5).multiplyScalar(400);var c=new THREE.SpotLight(4882408,0,4E3,Math.PI/6,.2,.11);c.baseIntensity=2;c.position.set(-.91,.1,-.5).multiplyScalar(400);var e=new THREE.SpotLight(16777215,0,4E3,Math.PI/5.5,1.4,.08);e.baseIntensity=1.5;e.position.set(0,0,-1).multiplyScalar(400);e.castShadow=!0;e.shadow.radius=5;e.shadow.camera.far=
4E3;e.shadow.mapSize.height=1024;e.shadow.mapSize.width=1024;var f=new THREE.DirectionalLight(16777215,0);f.baseIntensity=.3;f.position.set(0,1,.5);var g=new THREE.DirectionalLight(16777215,0);g.baseIntensity=1.3;g.position.set(0,1,-.4);a.add(b,d,c,e,f,g);objects=[b,d,c,e,f,g]}function easing(a,b){return 1>(a/=.5)?b/2*a*a*a:b/2*((a-=2)*a*a+2)}
function update$1(){var a=clock.getElapsedTime();if(1<a&&4>a)for(var b=0;b<objects.length;b++)objects[b].intensity=objects[b].baseIntensity*easing((a-1)/3,1)}var renderer$1,camera$2,scene$1;
function init$5(){renderer$1=new THREE.WebGLRenderer({antialias:!0});renderer$1.setSize(window.innerWidth,window.innerHeight);renderer$1.setPixelRatio(window.devicePixelRatio);renderer$1.gammaOutput=!0;renderer$1.physicallyCorrectLights=!0;renderer$1.shadowMap.enabled=!0;renderer$1.shadowMap.type=THREE.PCFShadowMap;document.body.appendChild(renderer$1.domElement);scene$1=new THREE.Scene;scene$1.background=new THREE.Color(1184530);camera$2=new THREE.PerspectiveCamera(60,window.innerWidth/window.innerHeight,
1,4E3);camera$2.position.set(0,-50,-350);camera$2.lookAt(new THREE.Vector3);calculate();init(scene$1);init$4(scene$1);init$3(scene$1);init$1(camera$2,renderer$1.domElement);init$2(renderer$1);dispose();animate()}function animate(){update$1();update();renderer$1.setRenderTarget(null);renderer$1.render(scene$1,camera$2);requestAnimationFrame(animate)}window.onresize=function(){var a=window.innerWidth,b=window.innerHeight;camera$2.aspect=a/b;camera$2.updateProjectionMatrix();renderer$1.setSize(a,b)};
init$5();

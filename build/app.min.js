var $jscomp=$jscomp||{};$jscomp.scope={};$jscomp.arrayIteratorImpl=function(a){var b=0;return function(){return b<a.length?{done:!1,value:a[b++]}:{done:!0}}};$jscomp.arrayIterator=function(a){return{next:$jscomp.arrayIteratorImpl(a)}};$jscomp.makeIterator=function(a){var b="undefined"!=typeof Symbol&&Symbol.iterator&&a[Symbol.iterator];return b?b.call(a):$jscomp.arrayIterator(a)};$jscomp.ASSUME_ES5=!1;$jscomp.ASSUME_NO_NATIVE_MAP=!1;$jscomp.ASSUME_NO_NATIVE_SET=!1;$jscomp.SIMPLE_FROUND_POLYFILL=!1;
$jscomp.defineProperty=$jscomp.ASSUME_ES5||"function"==typeof Object.defineProperties?Object.defineProperty:function(a,b,d){a!=Array.prototype&&a!=Object.prototype&&(a[b]=d.value)};$jscomp.getGlobal=function(a){return"undefined"!=typeof window&&window===a?a:"undefined"!=typeof global&&null!=global?global:a};$jscomp.global=$jscomp.getGlobal(this);
$jscomp.polyfill=function(a,b,d,c){if(b){d=$jscomp.global;a=a.split(".");for(c=0;c<a.length-1;c++){var e=a[c];e in d||(d[e]={});d=d[e]}a=a[a.length-1];c=d[a];b=b(c);b!=c&&null!=b&&$jscomp.defineProperty(d,a,{configurable:!0,writable:!0,value:b})}};
$jscomp.polyfill("Array.from",function(a){return a?a:function(a,d,c){d=null!=d?d:function(a){return a};var b=[],f="undefined"!=typeof Symbol&&Symbol.iterator&&a[Symbol.iterator];if("function"==typeof f){a=f.call(a);for(var g=0;!(f=a.next()).done;)b.push(d.call(c,f.value,g++))}else for(f=a.length,g=0;g<f;g++)b.push(d.call(c,a[g],g));return b}},"es6","es3");$jscomp.owns=function(a,b){return Object.prototype.hasOwnProperty.call(a,b)};
$jscomp.polyfill("Object.entries",function(a){return a?a:function(a){var b=[],c;for(c in a)$jscomp.owns(a,c)&&b.push([c,a[c]]);return b}},"es8","es3");$jscomp.checkStringArgs=function(a,b,d){if(null==a)throw new TypeError("The 'this' value for String.prototype."+d+" must not be null or undefined");if(b instanceof RegExp)throw new TypeError("First argument to String.prototype."+d+" must not be a regular expression");return a+""};
$jscomp.polyfill("String.prototype.repeat",function(a){return a?a:function(a){var b=$jscomp.checkStringArgs(this,null,"repeat");if(0>a||1342177279<a)throw new RangeError("Invalid count value");a|=0;for(var c="";a;)if(a&1&&(c+=b),a>>>=1)b+=b;return c}},"es6","es3");
function init(a){var b=new THREE.MeshPhysicalMaterial({color:3750201,metalness:.9,roughness:.4,dithering:!0}),d=new THREE.PlaneBufferGeometry(16E3,16E3);b=new THREE.Mesh(d,b);b.receiveShadow=!0;b.rotation.x+=.9*Math.PI;b.position.set(0,-100,2E3);a.add(b)}var geometry,adjacency,vertices;function calculate(){var a=new THREE.IcosahedronBufferGeometry(1E3,5);geometry=THREE.BufferGeometryUtils.mergeVertices(a,1.2);geometry.scale(9.5E-4,9.5E-4,9.5E-4);populateVertices();populateAdjacency()}
function populateVertices(){var a=new THREE.Vector3,b=geometry.attributes.position;vertices=[];for(var d=0,c=b.count;d<c;d++)a.fromBufferAttribute(b,d),vertices.push(a.clone())}
function populateAdjacency(){function a(a,b,c){for(var d=0;d<a.length;d++){var e=a[d];if(e.a===b&&e.b===c||e.b===b&&e.c===c||e.c===b&&e.a===c)return e}console.error("sheen.error: shouldn't reach here.")}for(var b=geometry.index,d=Array.from({length:vertices.length},function(){return[]}),c=0,e=b.count/3;c<e;c++){var f=3*c,g=b.getX(f+0),h=b.getX(f+1);f=b.getX(f+2);var l=new THREE.Face3(g,h,f);d[g].push(l);d[h].push(l);d[f].push(l)}adjacency=Array.from({length:vertices.length},function(){return[]});
for(b=0;b<d.length;b++)for(c=d[b][0];c.a==b?(adjacency[b].push(c.c),c=a(d[b],b,c.c)):c.b==b?(adjacency[b].push(c.a),c=a(d[b],b,c.a)):(adjacency[b].push(c.b),c=a(d[b],b,c.b)),c!=d[b][0];);}function dispose(){adjacency=geometry=void 0}var camera,pointers={},vertices$1=Array(3),coordinates=Array(3),tmpmouse=new THREE.Vector3,mouse3d=new THREE.Vector3,raycaster=new THREE.Raycaster,plane=new THREE.Plane(void 0,-1.8),sphere=new THREE.Sphere(void 0,1);
function init$1(a){camera=a;plane.normal.copy(camera.position).normalize();window.addEventListener("mousemove",onMouseMove);window.addEventListener("mousedown",onMouseDown);window.addEventListener("mouseout",onMouseOut);window.addEventListener("mouseup",onMouseUp);window.addEventListener("touchmove",onTouchMove,{passive:!1});window.addEventListener("touchstart",onTouchDown,{passive:!1});window.addEventListener("touchend",onTouchUp)}
function updating(){for(var a=0,b=!1,d=$jscomp.makeIterator(Object.entries(pointers)),c=d.next();!c.done;c=d.next()){c=$jscomp.makeIterator(c.value);c.next();c=c.next().value;raycaster.setFromCamera(c.screenCoordinate,camera);if(void 0===c.vertex&&null!=raycaster.ray.intersectSphere(sphere,tmpmouse)){mouse3d.copy(tmpmouse);for(var e=Infinity,f=0;f<vertices.length;++f){var g=mouse3d.distanceTo(vertices[f]);g<e&&(e=g,c.vertex=f)}}void 0!==c.vertex&&(b=!0,raycaster.ray.intersectPlane(plane,tmpmouse),
c.worldCoordinate.copy(tmpmouse),vertices$1[a]=c.vertex,coordinates[a]=c.worldCoordinate,a++)}for(;3>a;)vertices$1[a]=-1,coordinates[a]=mouse3d,a++;return b?!0:!1}function onMouseMove(a){void 0!==pointers.mouse&&(pointers.mouse.screenCoordinate.x=a.pageX/window.innerWidth*2-1,pointers.mouse.screenCoordinate.y=2*-(a.pageY/window.innerHeight)+1)}function onMouseDown(a){0==a.button&&(pointers.mouse={vertex:void 0,screenCoordinate:new THREE.Vector2,worldCoordinate:new THREE.Vector3},onMouseMove(a))}
function onMouseUp(a){0==a.button&&delete pointers.mouse}function onMouseOut(){delete pointers.mouse}function onTouchMove(a){a.preventDefault();for(var b=0;b<a.changedTouches.length;++b){var d=a.changedTouches[b];pointers[d.identifier].screenCoordinate.x=d.pageX/window.innerWidth*2-1;pointers[d.identifier].screenCoordinate.y=2*-(d.pageY/window.innerHeight)+1}}
function onTouchDown(a){for(var b=0;b<a.changedTouches.length;++b)pointers[a.changedTouches[b].identifier]={vertex:void 0,screenCoordinate:new THREE.Vector2,worldCoordinate:new THREE.Vector3};onTouchMove(a)}function onTouchUp(a){for(var b=0;b<a.changedTouches.length;++b)delete pointers[a.changedTouches[b].identifier]}
var through_vert="\nprecision highp float;\n\nattribute vec2 position;\n\nvoid main() {\n\n\tgl_Position = vec4( position, vec2(1.0) );\n\n}\n",constraints_frag="\nprecision highp float;\nprecision highp sampler2D;\n\nuniform vec2 tSize;\nuniform float order;\nuniform sampler2D tPosition0;\nuniform sampler2D tPosition1;\n\nuniform sampler2D tDistancesA;\nuniform sampler2D tDistancesB;\n\nuniform sampler2D tAdjacentsA;\nuniform sampler2D tAdjacentsB;\n\n// get vec2 tex coordinate from index\nvec2 getUV( float id ) { \n\n\tvec2 coords = vec2(\n\t\tfloor( mod( ( id + 0.5 ), tSize.x ) ),\n\t\tfloor( ( id + 0.5 ) / tSize.x )\n\t) + 0.5;\n\n\treturn coords / tSize;\n\n}\n\n// compute offset based on current distance and spring rest distance\nvec3 getDisplacement( vec3 point0, vec3 point1, float restDistance ) {\n\n    float curDistance = distance( point0, point1 );\n\treturn 1.5 * ( curDistance - restDistance ) * ( point1 - point0 ) / curDistance;\n\t\n}\n\n// pack float16 position into float32\nvec3 packPosition( vec2 uv ) {\n\n\treturn ( texture2D( tPosition0, uv ).xyz + texture2D( tPosition1, uv ).xyz ) / 1024.0;\n\n}\n\nvec3 unpackPosition( vec3 pos ) {\n\n\tpos *= 1024.0;\n\n\treturn ( order > 0.0 ) ? floor( pos ) : fract( pos );\n\n}\n\nvoid main() {\n\t\n\tvec3 displacement;\n\tvec2 uv = gl_FragCoord.xy / tSize.xy;\n\n\t// indices of adjacent vertices\n\tvec4 adjacentA = texture2D( tAdjacentsA, uv );\n\tvec4 adjacentB = texture2D( tAdjacentsB, uv );\n\n\t// distances of adjacent vertices\n\tvec4 distancesA = texture2D( tDistancesA, uv );\n\tvec4 distancesB = texture2D( tDistancesB, uv );\n\n\t// vertex position\n\tvec3 p0 = packPosition( uv );\n\n\t// adjacent vertices positions\n    vec3 p1 = packPosition( getUV( adjacentA.x ) );\n    vec3 p2 = packPosition( getUV( adjacentA.y ) );\n    vec3 p3 = packPosition( getUV( adjacentA.z ) );\n    vec3 p4 = packPosition( getUV( adjacentA.w ) );\n    vec3 p5 = packPosition( getUV( adjacentB.x ) );\n\tvec3 p6 = packPosition( getUV( adjacentB.y ) );\n\t\n\t// spring-based displacement\n    displacement += getDisplacement( p0, p1, distancesA.x );\n    displacement += getDisplacement( p0, p2, distancesA.y );\n    displacement += getDisplacement( p0, p3, distancesA.z );\n    displacement += getDisplacement( p0, p4, distancesA.w );\n    displacement += getDisplacement( p0, p5, distancesB.x );\n    displacement += ( adjacentB.y > 0.0 ) ? getDisplacement( p0, p6, distancesB.y ) : vec3( 0 );\n\n\tp0 += 0.76 * displacement / ( ( adjacentB.y > 0.0 ) ? 6.0 : 5.0 );\n\n\tgl_FragColor = vec4( unpackPosition( p0 ), 1.0 );\n\n}\n",integrate_frag=
"\nprecision highp float;\nprecision highp sampler2D;\n\nuniform vec2 tSize;\nuniform float order;\nuniform sampler2D tOriginal;\nuniform sampler2D tPrevious0;\nuniform sampler2D tPrevious1;\nuniform sampler2D tPosition0;\nuniform sampler2D tPosition1;\n\n#define dt2 0.000256\n\nvec3 unpackPosition( vec3 pos ) {\n\n\tpos *= 1024.0;\n\n\treturn ( order > 0.0 ) ? floor( pos ) : fract( pos );\n\n}\n\nvoid main() {\n\n\tvec2 uv = gl_FragCoord.xy / tSize.xy;\n\n\tvec3 org = texture2D( tOriginal, uv ).xyz;\n\tvec3 prv = ( texture2D( tPrevious0, uv ).xyz + texture2D( tPrevious1, uv ).xyz ) / 1024.0;\n\tvec3 pos = ( texture2D( tPosition0, uv ).xyz + texture2D( tPosition1, uv ).xyz ) / 1024.0;\n\n\tvec3 offset = ( org - pos ) * 18.5 * dt2 * 8.33333;\n\tvec3 disp = ( pos - prv ) * 0.94 + pos;\n\n\tgl_FragColor = vec4( unpackPosition( disp + offset ), 1.0 );\n\n}\n",
mouse_frag="\nprecision highp float;\nprecision highp sampler2D;\n\nuniform float vertices[3];\nuniform vec3 coordinates[3];\n\nuniform vec2 tSize;\nuniform float order;\nuniform sampler2D tPosition0;\nuniform sampler2D tPosition1;\nuniform sampler2D tOriginal;\n\n// get vec2 tex coordinate from index\nvec2 getUV( float id ) { \n\n\tvec2 coords = vec2(\n\t\tfloor( mod( ( id + 0.5 ), tSize.x ) ),\n\t\tfloor( ( id + 0.5 ) / tSize.x )\n\t) + 0.5;\n\n\treturn coords / tSize;\n\n}\n\n// pack float16 position into float32\nvec3 packPosition( vec2 uv ) {\n\n\treturn ( texture2D( tPosition0, uv ).xyz + texture2D( tPosition1, uv ).xyz ) / 1024.0;\n\n}\n\nvec3 unpackPosition( vec3 pos ) {\n\n\tpos *= 1024.0;\n\n\treturn ( order > 0.0 ) ? floor( pos ) : fract( pos );\n\n}\n\nvoid main() {\n\n\tvec2 uv = gl_FragCoord.xy / tSize.xy;\n\n\tvec3 pos = packPosition( uv );\n\tvec3 org = texture2D( tOriginal, uv ).xyz;\n\n\tvec3 ref, diff, proj, offset;\n\t\n\tfor ( int i = 0; i < 3; ++i ) {\n\n\t\tif ( vertices[ i ] == - 1.0 ) continue;\n\n\t\tref = texture2D( tOriginal, getUV( vertices[ i ] ) ).xyz;\n\t\toffset = coordinates[ i ] - ref;\n\n\t\tif ( distance( org, ref ) <= 0.1 )  {\n\n\t\t\tdiff = ref - org;\n\n\t\t\tproj = dot( diff, offset ) / dot( offset, offset ) * org;\n\n\t\t\tpos = org + proj + offset;\n\n\t\t}\n\n\t}\n\n\tgl_FragColor = vec4( unpackPosition( pos ), 1.0 );\n\n}\n",
normals_frag="\nprecision highp float;\nprecision highp sampler2D;\n\nuniform vec2 tSize;\n\nuniform sampler2D tPosition0;\nuniform sampler2D tPosition1;\n\nuniform sampler2D tAdjacentsA;\nuniform sampler2D tAdjacentsB;\n\n// get vec2 tex coordinate from index\nvec2 getUV( float id ) { \n\n\tvec2 coords = vec2(\n\t\tfloor( mod( ( id + 0.5 ), tSize.x ) ),\n\t\tfloor( ( id + 0.5 ) / tSize.x )\n\t) + 0.5;\n\n\treturn coords / tSize;\n\n}\n\n// pack float16 position into float32\nvec3 packPosition( vec2 uv ) {\n\n\treturn ( texture2D( tPosition0, uv ).xyz + texture2D( tPosition1, uv ).xyz ) / 1024.0;\n\n}\n\nvoid main () {\n\n    vec3 normal;\n\tvec2 uv = gl_FragCoord.xy / tSize.xy;\n\n    // indices of adjacent vertices\n\tvec4 adjacentA = texture2D( tAdjacentsA, uv );\n\tvec4 adjacentB = texture2D( tAdjacentsB, uv );\n\n    // vertex position\n\tvec3 p0 = ( texture2D( tPosition0, uv ).xyz + texture2D( tPosition1, uv ).xyz ) / 1024.0;\n\n\t// adjacent vertices positions\n    vec3 p1 = packPosition( getUV( adjacentA.x ) );\n    vec3 p2 = packPosition( getUV( adjacentA.y ) );\n    vec3 p3 = packPosition( getUV( adjacentA.z ) );\n    vec3 p4 = packPosition( getUV( adjacentA.w ) );\n    vec3 p5 = packPosition( getUV( adjacentB.x ) );\n\tvec3 p6 = packPosition( getUV( adjacentB.y ) );\n    \n    // compute vertex normal contribution\n    normal += cross( p1 - p0, p2 - p0 );\n    normal += cross( p2 - p0, p3 - p0 );\n    normal += cross( p3 - p0, p4 - p0 );\n    normal += cross( p4 - p0, p5 - p0 );\n\n    if ( adjacentB.y > 0.0 ) {\n\n        normal += cross( p5 - p0, p6 - p0 );\n        normal += cross( p6 - p0, p1 - p0 );\n\n    } else {\n\n        normal += cross( p5 - p0, p1 - p0 );\n\n    }\n\n    gl_FragColor = vec4( normalize( normal ), 1.0 );\n}\n",
through_frag="\nprecision highp float;\nprecision highp sampler2D;\n\nuniform vec2 tSize;\nuniform float order;\nuniform sampler2D texture;\n\nvec4 unpackPosition( vec4 pos ) {\n\n\tpos *= 1024.0;\n\n\treturn ( order > 0.0 ) ? floor( pos ) : fract( pos );\n\n}\n\nvoid main() {\n\n\tvec2 uv = gl_FragCoord.xy / tSize.xy;\n\n\tgl_FragColor = unpackPosition( texture2D( texture, uv ) );\n\n}\n",copyShader=new THREE.RawShaderMaterial({uniforms:{order:{},tSize:{type:"v2"},texture:{type:"t"}},vertexShader:through_vert,
fragmentShader:through_frag,fog:!1,lights:!1,depthWrite:!1,depthTest:!1}),integrateShader=copyShader.clone();integrateShader.fragmentShader=integrate_frag;integrateShader.uniforms={dt:{type:"f"},tSize:{type:"v2"},order:{},tOriginal:{type:"t"},tPrevious0:{type:"t"},tPrevious1:{type:"t"},tPosition0:{type:"t"},tPosition1:{type:"t"}};var mouseShader=copyShader.clone();mouseShader.fragmentShader=mouse_frag;
mouseShader.uniforms={vertices:{value:null},coordinates:{type:"v3"},order:{},tSize:{type:"v2"},tOriginal:{type:"t"},tPosition0:{type:"t"},tPosition1:{type:"t"}};var constraintsShader=copyShader.clone();constraintsShader.fragmentShader=constraints_frag;constraintsShader.uniforms={tSize:{type:"v2"},order:{},tPosition0:{type:"t"},tPosition1:{type:"t"},tAdjacentsA:{type:"t"},tAdjacentsB:{type:"t"},tDistancesA:{type:"t"},tDistancesB:{type:"t"}};var normalsShader=copyShader.clone();
normalsShader.fragmentShader=normals_frag;normalsShader.uniforms={tSize:{type:"v2"},tPosition0:{type:"t"},tPosition1:{type:"t"},tAdjacentsA:{type:"t"},tAdjacentsB:{type:"t"}};var RESOLUTION,renderer,mesh,targetRT,normalsRT,originalRT,previousRT,positionRT,adjacentsRT,distancesRT,steps=40,tSize=new THREE.Vector2,scene=new THREE.Scene,camera$1=new THREE.Camera;
function init$2(a){renderer=a;RESOLUTION=Math.ceil(Math.sqrt(vertices.length));tSize.set(RESOLUTION,RESOLUTION);a=new THREE.BufferGeometry;var b=new Float32Array([-1,-1,3,-1,-1,3]);a.addAttribute("position",new THREE.BufferAttribute(b,2));mesh=new THREE.Mesh(a,copyShader);mesh.frustumCulled=!1;scene.add(mesh);scene.updateMatrixWorld=function(){};adjacentsRT=Array(2);distancesRT=Array(2);positionRT=Array(2);previousRT=Array(2);targetRT=Array(2);normalsRT=createRenderTarget();createPositionTexture();
for(a=0;2>a;a++)createAdjacentsTexture(a),createDistancesTexture(a),positionRT[a]=createRenderTarget(),previousRT[a]=createRenderTarget(),targetRT[a]=createRenderTarget(),copyTexture(originalRT,positionRT[a],!a),copyTexture(originalRT,previousRT[a],!a)}function copyTexture(a,b,d){mesh.material=copyShader;copyShader.uniforms.order.value=d?1:-1;copyShader.uniforms.tSize.value=tSize;copyShader.uniforms.texture.value=a.texture;renderer.setRenderTarget(b);renderer.render(scene,camera$1)}
function createRenderTarget(){return new THREE.WebGLRenderTarget(RESOLUTION,RESOLUTION,{wrapS:THREE.ClampToEdgeWrapping,wrapT:THREE.ClampToEdgeWrapping,minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter,format:THREE.RGBAFormat,type:THREE.HalfFloatType,depthTest:!1,depthWrite:!1,depthBuffer:!1,stencilBuffer:!1})}
function createPositionTexture(){for(var a=new Float32Array(RESOLUTION*RESOLUTION*4),b=vertices.length,d=0;d<b;d++){var c=4*d;a[c+0]=vertices[d].x;a[c+1]=vertices[d].y;a[c+2]=vertices[d].z}b={};b.texture=new THREE.DataTexture(a,RESOLUTION,RESOLUTION,THREE.RGBAFormat,THREE.FloatType);b.texture.needsUpdate=!0;originalRT=b}
function createAdjacentsTexture(a){for(var b=new Float32Array(RESOLUTION*RESOLUTION*4),d=vertices.length,c=0;c<d;c++)for(var e=4*c,f=adjacency[c],g=adjacency[c].length-1,h=0;4>h;h++)b[e+h]=g<4*a+h?-1:f[4*a+h];d={};d.texture=new THREE.DataTexture(b,RESOLUTION,RESOLUTION,THREE.RGBAFormat,THREE.FloatType);d.texture.needsUpdate=!0;adjacentsRT[a]=d}
function createDistancesTexture(a){for(var b=new Float32Array(RESOLUTION*RESOLUTION*4),d=vertices.length,c=vertices,e=0;e<d;e++)for(var f=4*e,g=adjacency[e],h=adjacency[e].length-1,l=c[e],k=0;4>k;k++)b[f+k]=h<4*a+k?-1:l.distanceTo(c[g[4*a+k]]);d={};d.texture=new THREE.DataTexture(b,RESOLUTION,RESOLUTION,THREE.RGBAFormat,THREE.FloatType);d.texture.needsUpdate=!0;distancesRT[a]=d}
function integrate(){mesh.material=integrateShader;integrateShader.uniforms.tSize.value=tSize;integrateShader.uniforms.tOriginal.value=originalRT.texture;integrateShader.uniforms.tPrevious0.value=previousRT[0].texture;integrateShader.uniforms.tPrevious1.value=previousRT[1].texture;integrateShader.uniforms.tPosition0.value=positionRT[0].texture;integrateShader.uniforms.tPosition1.value=positionRT[1].texture;integrateShader.uniforms.order.value=1;renderer.setRenderTarget(targetRT[0]);renderer.render(scene,
camera$1);integrateShader.uniforms.order.value=-1;renderer.setRenderTarget(targetRT[1]);renderer.render(scene,camera$1);var a=previousRT[0];previousRT[0]=positionRT[0];positionRT[0]=targetRT[0];targetRT[0]=a;a=previousRT[1];previousRT[1]=positionRT[1];positionRT[1]=targetRT[1];targetRT[1]=a}
function solveConstraints(){mesh.material=constraintsShader;constraintsShader.uniforms.tSize.value=tSize;constraintsShader.uniforms.tPosition0.value=positionRT[0].texture;constraintsShader.uniforms.tPosition1.value=positionRT[1].texture;constraintsShader.uniforms.tAdjacentsA.value=adjacentsRT[0].texture;constraintsShader.uniforms.tAdjacentsB.value=adjacentsRT[1].texture;constraintsShader.uniforms.tDistancesA.value=distancesRT[0].texture;constraintsShader.uniforms.tDistancesB.value=distancesRT[1].texture;
constraintsShader.uniforms.order.value=1;renderer.setRenderTarget(targetRT[0]);renderer.render(scene,camera$1);constraintsShader.uniforms.order.value=-1;renderer.setRenderTarget(targetRT[1]);renderer.render(scene,camera$1);var a=positionRT[0];positionRT[0]=targetRT[0];targetRT[0]=a;a=positionRT[1];positionRT[1]=targetRT[1];targetRT[1]=a}
function mouseOffset(){mesh.material=mouseShader;mouseShader.uniforms.tSize.value=tSize;mouseShader.uniforms.vertices.value=vertices$1;mouseShader.uniforms.coordinates.value=coordinates;mouseShader.uniforms.tOriginal.value=originalRT.texture;mouseShader.uniforms.tPosition0.value=positionRT[0].texture;mouseShader.uniforms.tPosition1.value=positionRT[1].texture;mouseShader.uniforms.order.value=1;renderer.setRenderTarget(targetRT[0]);renderer.render(scene,camera$1);mouseShader.uniforms.order.value=-1;
renderer.setRenderTarget(targetRT[1]);renderer.render(scene,camera$1);var a=positionRT[0];positionRT[0]=targetRT[0];targetRT[0]=a;a=positionRT[1];positionRT[1]=targetRT[1];targetRT[1]=a}
function computeVertexNormals(){mesh.material=normalsShader;normalsShader.uniforms.tSize.value=tSize;normalsShader.uniforms.tPosition0.value=positionRT[0].texture;normalsShader.uniforms.tPosition1.value=positionRT[1].texture;normalsShader.uniforms.tAdjacentsA.value=adjacentsRT[0].texture;normalsShader.uniforms.tAdjacentsB.value=adjacentsRT[1].texture;renderer.setRenderTarget(normalsRT);renderer.render(scene,camera$1)}
function update(){integrate();for(var a=updating(),b=0;b<steps;b++)a&&b<steps-5&&mouseOffset(),solveConstraints();computeVertexNormals()}var RESOLUTION$1,mesh$1;
function init$3(a){RESOLUTION$1=Math.ceil(Math.sqrt(vertices.length));var b=(new THREE.TextureLoader).load("./src/textures/bmpMap.png");b.wrapS=THREE.RepeatWrapping;b.wrapT=THREE.RepeatWrapping;b.repeat.set(2.5,2.5);b=new THREE.MeshPhysicalMaterial({color:16767520,bumpMap:b,bumpScale:.012,metalness:.1,roughness:.6,clearcoat:.8,clearcoatRoughness:.35,sheen:(new THREE.Color(.2,.2,1)).multiplyScalar(1/6),dithering:!0});b.onBeforeCompile=function(a){a.uniforms.tPosition0={value:positionRT[0].texture};
a.uniforms.tPosition1={value:positionRT[1].texture};a.uniforms.tNormal={value:normalsRT.texture};a.vertexShader="precision highp sampler2D;\nuniform sampler2D tPosition0;\nuniform sampler2D tPosition1;\nuniform sampler2D tNormal;\n"+a.vertexShader;a.vertexShader=a.vertexShader.replace("#include <beginnormal_vertex>","vec3 transformed = ( texture2D( tPosition0, position.xy ).xyz + texture2D( tPosition1, position.xy ).xyz ) / 1024.0;\n\t\t\t vec3 objectNormal = normalize( texture2D( tNormal, position.xy ).xyz );\n\t\t\t");
a.vertexShader=a.vertexShader.replace("#include <begin_vertex>","")};var d=new THREE.MeshDepthMaterial;d.onBeforeCompile=function(a){a.uniforms.tPosition0={value:positionRT[0].texture};a.uniforms.tPosition1={value:positionRT[1].texture};a.vertexShader="precision highp sampler2D;\nuniform sampler2D tPosition0;\nuniform sampler2D tPosition1;\n"+a.vertexShader;a.vertexShader=a.vertexShader.replace("#include <begin_vertex>","vec3 transformed = ( texture2D( tPosition0, position.xy ).xyz + texture2D( tPosition1, position.xy ).xyz ) / 1024.0;")};
for(var c=new Float32Array(RESOLUTION$1*RESOLUTION$1*3),e=0,f=RESOLUTION$1*RESOLUTION$1;e<f;e++){var g=3*e;c[g+0]=e%RESOLUTION$1/RESOLUTION$1+.5/RESOLUTION$1;c[g+1]=~~(e/RESOLUTION$1)/RESOLUTION$1+.5/RESOLUTION$1}e=new THREE.BufferGeometry;e.setIndex(geometry.index);e.addAttribute("position",new THREE.BufferAttribute(c,3));e.addAttribute("uv",geometry.attributes.uv);mesh$1=new THREE.Mesh(e,b);mesh$1.customDepthMaterial=d;mesh$1.castShadow=!0;a.add(mesh$1)}var objects,finished,clock=new THREE.Clock;
function init$4(a){var b=new THREE.AmbientLight(16777215,0);b.baseIntensity=.5;var d=new THREE.SpotLight(16616331,0,4E3,Math.PI/6,.2,.11);d.baseIntensity=3.6;d.position.set(.9,.1,-.5).multiplyScalar(400);var c=new THREE.SpotLight(4882408,0,4E3,Math.PI/6,.2,.11);c.baseIntensity=2;c.position.set(-.91,.1,-.5).multiplyScalar(400);var e=new THREE.SpotLight(16777215,0,4E3,Math.PI/5.5,1.4,.08);e.baseIntensity=1.5;e.position.set(0,0,-1).multiplyScalar(4);e.castShadow=!0;e.shadow.radius=3;e.shadow.camera.far=
4E3;e.shadow.mapSize.height=256;e.shadow.mapSize.width=256;var f=new THREE.DirectionalLight(16777215,0);f.baseIntensity=.3;f.position.set(0,1,.5);var g=new THREE.DirectionalLight(16777215,0);g.baseIntensity=1.3;g.position.set(0,1,-.4);a.add(b,d,c,e,f,g);objects=[b,d,c,e,f,g];finished=!1}function easing(a,b){return 1>(a/=.5)?b/2*a*a*a:b/2*((a-=2)*a*a+2)}function updateLights(a){for(var b=0;b<objects.length;b++)objects[b].intensity=objects[b].baseIntensity*easing((a-1)/3,1)}
function update$1(){if(!finished){var a=clock.getElapsedTime();1<a&&4>a?updateLights(a):4<a&&(updateLights(4),finished=!0)}}var renderer$1,camera$2,scene$1,lastOrientation;
function init$5(){renderer$1=new THREE.WebGLRenderer({antialias:!0});renderer$1.setSize(window.innerWidth,window.innerHeight);renderer$1.gammaOutput=!0;renderer$1.physicallyCorrectLights=!0;renderer$1.shadowMap.enabled=!0;renderer$1.shadowMap.type=THREE.PCFShadowMap;document.body.appendChild(renderer$1.domElement);window.addEventListener("resize",onResize);scene$1=new THREE.Scene;scene$1.background=new THREE.Color(1184530);camera$2=new THREE.PerspectiveCamera(60,window.innerWidth/window.innerHeight,
.1,4E3);camera$2.position.set(0,-.5,-3.5);camera$2.lookAt(new THREE.Vector3);calculate();init(scene$1);init$3(scene$1);init$1(camera$2,renderer$1.domElement);init$2(renderer$1);dispose();init$4(scene$1);animate()}function animate(){window.orientation!=lastOrientation&&(lastOrientation=window.orientation,onResize());update$1();update();renderer$1.setRenderTarget(null);renderer$1.render(scene$1,camera$2);requestAnimationFrame(animate)}
function onResize(){var a=window.innerWidth,b=window.innerHeight;camera$2.aspect=a/b;camera$2.updateProjectionMatrix();renderer$1.setSize(a,b)}init$5();
